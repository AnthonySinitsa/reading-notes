# classes and objects

1. Definition: A class is defined using the class keyword followed by a name, whereas an object is created from a class using the class name followed by parentheses. Structure: A class consists of attributes (variables) and methods (functions), which define the behavior and data associated with the class. An object, on the other hand, contains the actual values of those attributes and can invoke the methods defined in its class. Instantiation: To create an object, you need to instantiate a class. This is done by calling the class name followed by parentheses, optionally passing any required arguments to the class's constructor method called __init__(). The __init__() method is responsible for initializing the object's attributes.

2. It involves breaking down a complex problem into smaller, simpler instances of the same problem until a base case is reached, which is a simple case that can be solved directly. Recursion allows solving problems by dividing them into smaller subproblems, solving each subproblem recursively, and combining the results to obtain the final solution.

3. Code Reusability: Fixtures enable code reuse by allowing multiple tests to share common setup and teardown logic. Instead of duplicating the same code across multiple test functions, the shared setup can be encapsulated within a fixture, reducing redundancy and making tests more concise. Isolation and Dependency Management: Fixtures help isolate tests from each other by providing a fresh set of resources for each test. They allow you to control the state of the system under test, ensuring that tests are independent and not affected by the execution order. Additionally, fixtures can manage complex dependencies by automatically resolving and providing them to the tests, simplifying test configuration.
