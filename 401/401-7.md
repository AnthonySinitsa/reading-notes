# ten thousand 2

1. Local Scope: A variable has a local scope when it is defined within a function or a block of code, such as a loop or conditional statement. Local variables are only accessible within the function or block where they are defined. They cannot be accessed from outside that specific scope. Once the execution of the function or block is completed, local variables are destroyed, and their values are no longer accessible. Global Scope: A variable has a global scope when it is defined outside of any function or block, at the top level of the program. Global variables can be accessed from anywhere within the program, including within functions and blocks. If a variable is modified inside a function or block, Python assumes it to be a local variable unless explicitly declared as global using the global keyword.

2. global: This keyword is used to indicate that a variable inside a function should be treated as a global variable, rather than a local one. When you assign a value to a variable inside a function, Python creates a new local variable with the same name, which shadows any variable with the same name in the outer scope. By using the global keyword, you can explicitly specify that the variable refers to the global variable instead of creating a new local variable. nonlocal: This keyword is used to indicate that a variable inside a nested function should be treated as a nonlocal variable, rather than a new local variable. When you define a function inside another function, the inner function has its own local scope. If the inner function wants to access or modify a variable from the outer function's scope, you can use the nonlocal keyword to indicate that the variable is nonlocal.

3. The purpose of Big O notation is to quantify the scalability of an algorithm and understand how it performs as the input size becomes larger. It allows us to make predictions about an algorithm's behavior and estimate its efficiency in terms of time and space. By using Big O notation, we can gain insights into the fundamental characteristics of algorithms and make informed decisions when selecting or designing algorithms for specific tasks. The importance of Big O notation lies in its ability to provide a standardized language for discussing and classifying algorithms' efficiency. It allows us to express the growth rate of an algorithm's performance in a concise and abstract manner, independent of the specific hardware or software environment. This makes it easier to communicate and reason about algorithmic complexities, enabling us to identify bottlenecks, optimize algorithms, and make informed trade-offs in algorithm selection.

4.
        import random

        def roll_dice():
            return random.randint(1, 6)
